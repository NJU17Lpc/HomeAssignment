# 影院管理系统（TMS）软件详细设计描述文档



<a name="1pC1g"></a>
## 文档修改历史
| 修改人员 | 日期 | 修改原因 | 版本号 |
| :---: | :---: | :---: | :---: |
| 全体成员 | 2019.4.27 | 初始版本 | V1.0 |
| 全体成员 | 2019.4.28-4.30 | 添加各个包的详细设计内容 | V1.1 |
| 全体成员 | 2019.5.1-5.3 | 完善各个包的详细设计内容 | V1.2 |
| 全体成员 | 2019.5.4 | 最终调整 | V2.0 |

<a name="767fa455"></a>
## 目录
1.引言<br />      1.1 编制目的<br />      1.2 词汇表<br />      1.3 参考资料<br />2.产品概述<br />3.体系结构设计概念<br />4.结构视角<br />      4.1 业务逻辑层的分解<br />           4.1.1 vipbl模块<br />           4.1.2 salesbl模块<br />           4.1.3 moviebl模块 <br />           4.1.4 arrangementbl模块<br />           4.1.5 userbl模块<br />           4.1.6 statistics模块<br />           4.1.7 hallbl模块<br />5.依赖视角
<a name="b1MVB"></a>
## 1. 引言
<a name="98ebe8fa"></a>
###     1.1 编制目的
   本报告详细完成对影院管理系统的概要设计，达到指导性系设计和开发的目的，同时实现和测试人员及用户的沟通。<br />      
   本报告面向开发人员、测试人员及最终用户而编写，是为了了解系统的导航。
<a name="dbf8b345"></a>
###     1.2 词汇表
| 词汇名称 | 词汇含义 | 备注 |
| --- | --- | --- |
| TMS | 影院管理系统 | 无 |

<a name="9a346727"></a>
###     1.3 参考资料
1.软件工程与计算(卷二)——软件开发的技术基础/骆斌主编.-北京：机械工业出版社,2012.12（2018.4重印）<br />2.影院管理系统（TMS）用例文档 V1.0<br />3.影院管理系统（TMS）需求规格说明文档 V1.0

<a name="rg6FR"></a>
## 2. 产品概述
   参考影院管理系统用例文档和影院管理系统需求规格说明中对产品的概括描述。<br />

<a name="GhdsN"></a>
## 3. 系统结构设计概述
   参考影院管理系统概要设计文档中对体系结构设计的概述。

<a name="Pg3yr"></a>
## 4. 结构视角

<a name="KxhG5"></a>
###     4.1 业务逻辑层的分解
   业务逻辑层的开发包图参见软件体系结构文档图。

<a name="3It80"></a>
####         4.1.1 vipbl模块
   （1）模块概述<br />          vipbl 模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br />          Vipbl 模块的职责及接口参见软件系统结构描述文档表。<br />        （2）整体结构<br />          根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如在展示层和业务逻辑层之间，我们添加businesslogicservice.vipblservice.VipBLService接口。业务逻辑层和数据层之间添加dataservice.vipdataservice.VipDataService接口。为了隔离业务逻辑层职责和逻辑控制职责，我们增加了VipController，这样VipController将会对业务的销售逻辑处理委托给Vip对象。VipPO是作为会员卡的持久化对象被添加到设计模型中去的。CardTypeList、VipList和Card的添加是容器类。CardTypeList类里保有所有已发布的会员卡种类，VipList类里封装了所有已申请的Card信息，Card类里保有会员卡的id、对应用户、余额信息。payment保有支付功能。UserInfo负责与User之间的交互。<br />          vipbl 模块的设计图如图1所示：<br />![vip模块各个类的设计.png](https://cdn.nlark.com/yuque/0/2019/png/293520/1556877399125-cd6fcf31-a33b-4660-a8c2-a87b122822f8.png#align=left&display=inline&height=1114&name=vip%E6%A8%A1%E5%9D%97%E5%90%84%E4%B8%AA%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1.png&originHeight=1114&originWidth=1455&size=54951&status=done&width=1455)<br />**                                                     图1    vipbl 模块各个类的设计**<br /><br />          vipbl模块各个类的职责如表1所示：<br />**                                                       表1    vipbl 模块各个类的职责**

|                    模块 |                                            职责 |
| :--- | --- |
|             VipController | 负责实现会员卡界面所需要的服务 |
|                    Vip | 会员卡的领域模型对象，拥有会员列表、会员卡所持有用户、余额、消费记录、优惠策略，可以帮助完成会员卡相关界面所需要的服务 |
| CardTypeList | 会员卡所持有的会员卡种类的的领域模型对象，拥有所有已发行的会员卡类型（包含会员卡优惠策略） |
| VipList | 会员卡持有的会员列表的领域模型对象，拥有所有已成功申请的会员名单 |
| Card | 会员卡持有的单个会员卡的领域模型对象，拥有单张会员卡的id，对应用户，余额信息 |
| CardLog | 会员卡持有的单张会员卡消费记录的领域模型对象，拥有单张会员卡的详细消费信息 |

   （3）模块内部的接口规范<br /><br />          VipController和Vip的接口规范如表2和表3所示：<br />**                                                       表2    VipController 的接口规范**

|                                                         提供的服务（供接口） |  |  |
| --- | --- | --- |
|       VipController.purchase | 语法 | public ResultMessage purchase(CardType type) |
|  | 前置条件 | 已创建一个Vip领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Vip领域对象的purchase方法 |
|       VipController.delete | 语法 | public ResultMessage delete(Card card) |
|  | 前置条件 | 已创建一个Vip领域对象，会员卡已存在，并且输入符合输入规则 |
|  | 后置条件 | 调用Vip领域对象的delete方法 |
|       VipController.check | 语法 | public cardLog check(Card card) |
|  | 前置条件 | 已创建一个Vip领域对象，会员卡已存在，并且输入符合输入规则 |
|  | 后置条件 | 调用Vip领域对象的check方法 |
|       VipController.recharge | 语法 | public ResultMessage recharge(Card card,int money) |
|  | 前置条件 | 已创建一个Vip领域对象，会员卡已存在，并且输入符合输入规则 |
|  | 后置条件 | 调用Vip领域对象的recharge方法 |
|       VipController.release | 语法 | public ResultMessage release(CardType type,CardPreferentialStrategies preferentialStrategies) |
|  | 前置条件 | 已创建一个Vip领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Vip领域对象的release方法 |
|       VipController.adjust | 语法 | public ResultMessage release(CardType type,CardPreferentialStrategies preferentialStrategies) |
|  | 前置条件 | 已创建一个Vip领域对象，所选择会员卡优惠策略已存在，并且输入符合输入规则 |
|  | 后置条件 | 调用Vip领域对象的adjust方法 |
|                                                  需要的服务（需接口） |  |  |
| Vip.purchase(CardType type) |  | 购买会员卡 |
| Vip.delete(Card card) |  | 删除会员卡 |
| Vip.check(Card card) |  | 查看会员卡详情 |
| Vip.recharge(Card card,int money) |  | 充值会员卡 |
| Vip.release(CardType type,CardPreferentialStrategies preferentialStrategies) |  | 发布会员卡 |
| Vip.adjust(CardType type,CardPreferentialStrategies preferentialStrategies) |  | 修改会员卡 |

**                                                       表3    Vip 的接口规范**

| 提供的服务（供接口） |  |  |
| :---: | --- | --- |
| Vip.purchase | 语法 | public ResultMessage purchase(CardType type) |
|  | 前置条件 | 用户登录成功，且CardType不为空 |
|  | 后置条件 | 根据输入的card信息，增加涉及领域的持久化对象的数据，并返回购买结果 |
| Vip.delete | 语法 | public ResultMessage delete(Card card) |
|  | 前置条件 | card不为空且已存在 |
|  | 后置条件 | 根据card，删除涉及领域的持久化对象的数据，并返回删除结果 |
| Vip.check | 语法 | public cardLog check(Card card) |
|  | 前置条件 | card不为空且已存在 |
|  | 后置条件 | 根据card返回对应用户的会员信息 |
| Vip.recharge | 语法 | public ResultMessage recharge(Card card,int money) |
|  | 前置条件 | 选择充值，money不为空 |
|  | 后置条件 | 根据card，money修改涉及领域的持久化对象的数据，并返回充值结果 |
| Vip.release | 语法 | public ResultMessage release(CardType type,CardPreferentialStrategies preferentialStrategies) |
|  | 前置条件 | type,preferentialStrategies不为空 |
|  | 后置条件 | 根据type,preferentialStrategies更新涉及领域的持久化对象的数据，并返回发布结果 |
| Vip.adjust | 语法 | public ResultMessage adjust(CardType type,CardPreferentialStrategies preferentialStrategies) |
|  | 前置条件 | type,preferentialStrategies不为空，且此类卡已存在 |
|  | 后置条件 | 根据type,preferentialStrategies修改涉及领域的持久化对象的数据，并返回修改结果 |
| 需要的接口（需接口） |  |  |
| 服务名 |  | 服务 |
| DatabaseFacory.getVipDataBase |  | 得到Vip数据库的服务的引用 |
| VipDataService.insert(VipPO po) |  | 在数据库中插入单一持久化对象 |
| VipDataService.update(VipPO po) |  | 在数据库中更新单一持久化对象 |
| VipDataService.delete(VipPO po) |  | 在数据库中删除单一持久化对象 |
| VipDataService.find(int id) |  | 在数据库中查找单一持久化对象 |
| User.getUser(int id) |  | 根据id在User数据库中获得单一持久化对象 |


   （4）业务逻辑层的动态模型<br />          图2表明了影院管理系统中，当用户点击购买会员卡并选择卡类型之后，会员卡业务逻辑处理的相关对象之间的协作<br />![vip顺序图1.png](https://cdn.nlark.com/yuque/0/2019/png/293520/1556555816854-8ec7209d-07c4-4df7-aee8-fd3ca11f4ea3.png#align=left&display=inline&height=580&name=vip%E9%A1%BA%E5%BA%8F%E5%9B%BE1.png&originHeight=580&originWidth=1116&size=28434&status=done&width=1116)<br />**                                                       图2    购买会员卡的顺序图**<br />          图3为Vip领域对象想要删除会员卡时候的顺序图

![](https://cdn.nlark.com/yuque/0/2019/png/293520/1556556650422-31bd7f09-2759-461a-a533-8f7ecfa80fab.png#align=left&display=inline&height=388&originHeight=580&originWidth=1116&status=done&width=746)<br />**                                                       图3    删除会员卡的顺序图**<br />          图4为Vip领域对象想要查看会员卡时候的顺序图

![](https://cdn.nlark.com/yuque/0/2019/png/293520/1556558541480-d92e5440-87d7-49b6-8247-c27a8e8c6cba.png#align=left&display=inline&height=462&originHeight=579&originWidth=935&status=done&width=746)<br />**                                                       图4    查看会员卡的顺序图**<br />          图5为Vip领域对象想要充值会员卡时的顺序图

![](https://cdn.nlark.com/yuque/0/2019/png/293520/1556559510988-8edf03a2-6f88-4889-87f5-90f5c1927a86.png#align=left&display=inline&height=463&originHeight=580&originWidth=935&status=done&width=746)<br />**                                                      图5    充值会员卡的顺序图**<br />          <br />          图6为Sales领域对象想要发布会员卡时候的顺序图

![](https://cdn.nlark.com/yuque/0/2019/png/293520/1556560368955-1a52493a-e122-4b41-ab8a-fac34414dc44.png#align=left&display=inline&height=388&originHeight=580&originWidth=1116&status=done&width=746)<br />**                                                       图6    发布会员卡的顺序图**<br />          图7为Vip领域对象想要修改会员卡时的顺序图

![](https://cdn.nlark.com/yuque/0/2019/png/293520/1556561063464-0afa930c-683e-47a9-b210-9495a88c9d44.png#align=left&display=inline&height=388&originHeight=580&originWidth=1116&status=done&width=746)<br />**                                                       图7    修改会员卡的顺序图**<br />          图8所示的状态图描述了Vip对象的生存期间的状态序列、引起转移的事件，以及因状态转移而伴随的动作。<br />![vip状态图.png](https://cdn.nlark.com/yuque/0/2019/png/293520/1556893821783-d702e9b9-4f7e-4a30-90de-96f7c6754dbd.png#align=left&display=inline&height=614&name=vip%E7%8A%B6%E6%80%81%E5%9B%BE.png&originHeight=614&originWidth=1000&size=26211&status=done&width=1000)<br />**                                                       图8    Vip 对象状态图**<br />        （5）业务逻辑层的设计原理<br />          利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。
<a name="PEkec"></a>
#### 
<a name="ON7qQ"></a>
####         4.1.2 salesbl模块
   (1) 模块概述<br />          salesbl 模块承担的需求参见需求规格说明文档功能需求及相关非功能需求<br />          Salesbl 模块的职责及接口参见软件体系结构描述文档<br />          (2) 整体结构<br />          salesbl 模块的设计如图9所示<br />![salesbl模块各个类的设计.jpg](https://cdn.nlark.com/yuque/0/2019/jpeg/292738/1556938318096-f0ce6ab6-afb9-4bed-bb64-8231080dd2cc.jpeg#align=left&display=inline&height=1215&name=salesbl%E6%A8%A1%E5%9D%97%E5%90%84%E4%B8%AA%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1.jpg&originHeight=1215&originWidth=1515&size=103663&status=done&width=1515)<br />                                                        **图9    salesbl 模块各个类的设计**

   salesbl模块各个类的职责如表4所示<br />**                                                        表4    salesbl 模块各个类的职责**

| **                   模块** | **                                             职责** |
| --- | --- |
| LoginController | 负责实现对应于登陆界面所需要的服务 |
| SalesController | 负责实现销售界面所需要的服务 |
| User | 系统用户的领域模型对象，拥有用户数据的姓名和密码，可以解决登陆问题 |
| Sales | 销售的领域模型对象，拥有一次销售所持有的会员、购买影票对应的电影场次、购票总价、订单记录等信息，以及销售过程中的优惠策略和退票策略，可以帮助完成销售界面所需要的服务 |
| CouponList | 优惠券的领域模型对象，拥有优惠券的使用条件和优惠价格。若符合使用条件，观众可以使用优惠券减少买票所需支付的金额 |
| SalesPreferentialStrategy | 优惠策略的领域模型对象，拥有优惠策略的使用条件和优惠价格。若符合使用条件，观众可以选择相应的优惠策略来减少买票所需支付的金额 |
| RefundStrategy | 退款策略的领域模型对象，拥有退款策略的使用条件和退款金额。观众请求退款时，系统会根据退款策略来返还给观众一定的金额 |
| SalesLog | 销售记录的领域模型对象，拥有每次销售的Sales记录 |
| Order | 订单的领域模型对象，拥有电影场次、影厅、座位等信息，用于帮助用户确认买票选择和生成销售记录 |
| Pay | 支付的领域模型对象，用于生成订单后的支付结算流程 |



   (3)模块内部类的接口规范<br />          SalesController和Sales的接口规范如表5和表6所示<br />**表5    SalesController 的接口规范**

| 提供的服务（供接口） |  |  |
| :---: | --- | --- |
| SalesController.buyTicket | 语法 | public ResultMessage buyTicket(long userId, int filmId, Date date) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的buyTicket方法 |
| SalesController.getPrice | 语法 | public ResultMessage getPrice() |
|  | 前置条件 | 已创建一个Sales领域对象 |
|  | 后置条件 | 调用Sales领域对象的getPrice方法 |
| SalesController.pay | 语法 | public ResultMessage pay(int price) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的pay方法 |
| SalesController.endSales | 语法 | public void endSales() |
|  | 前置条件 | 已创建一个Sales领域对象 |
|  | 后置条件 | 调用Sales领域对象的endSales方法 |
| SalesController.getRefundPrice | 语法 | public ResultMessage getRefundPrice(Order order) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的getRefundPrice方法 |
| SalesController.refund | 语法 | public ResultMessage refund(int price) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的refund方法 |
| SalesController.addSalesPreferentialStrategy | 语法 | public ResultMessage addSalesPreferentialStrategy(SalesPreferentialStrategy salesPreferentialStrategy) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的addSalesPreferentialStrategy方法 |
| Sales.adjustSalesPreferentialStrategy | 语法 | public ResultMessage adjustSalesPreferentialStrategy(SalesPreferentialStrategy salesPreferentialStrategy) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的adjustSalesPreferentialStrategy方法 |
| SalesController.selectFilm | 语法 | public Film selectFilm(Film film) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的selectFilm方法 |
| SalesController.selectSeat | 语法 | public ResultMessage selectSeat(String seatLoc) |
|  | 前置条件 | 已创建一个Sales领域对象，已完成电影场次选择，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的selectSeat方法 |
| SalesController.showOrderInfo | 语法 | public void showOrderInfo() |
|  | 前置条件 | 已创建一个Sales领域对象，已完成电影场次和座位选择 |
|  | 后置条件 | 调用Sales领域对象的showOrderInfo方法 |
| SalesController.confirmOrder | 语法 | public void confirmOrder(boolean checked) |
|  | 前置条件 | 已创建一个Sales领域对象，已生成订单，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的confirmOrder方法 |
| SalesController.payStrategy | 语法 | public ResultMessage payStrategy(PayStrategy payStrategy) |
|  | 前置条件 | 已创建一个Sales领域对象，已确认订单并准备选择支付方式，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的payStrategy方法 |
| SalesController.cancelOrder | 语法 | public ResultMessage cancelOrder() |
|  | 前置条件 | 已创建一个Sales领域对象，已确认订单 |
|  | 后置条件 | 调用Sales领域对象的cancelOrder方法 |
| SalesController.addSalesLog | 语法 | public ResultMessage addSalesLog(long userId, int filmId, Date date, int price, SalesType salesType) |
|  | 前置条件 | 已创建一个Sales领域对象，已完成支付任务或退票任务，且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的addSalesLog方法 |
| SalesController.payLater | 语法 | public ResultMessage payLater() |
|  | 前置条件 | 已创建一个Sales领域对象，用户选择稍后支付或者支付时异常退出 |
|  | 后置条件 | 调用Sales领域对象的payLater方法 |
| SalesController.lockSeat | 语法 | public ResultMessage lockSeat() |
|  | 前置条件 | 已创建一个Sales领域对象，已完成确认订单任务 |
|  | 后置条件 | 调用Sales领域对象的lockSeat方法 |
| SalesController.unlockSeat | 语法 | public ResultMessage unlockSeat() |
|  | 前置条件 | 已创建一个Sales领域对象，已完成取消订单任务 |
|  | 后置条件 | 调用Sales领域对象的unlockSeat方法 |
| SalesController.addRefundStrategy | 语法 | public ResultMessage addRefundStrategy(RefundStrategy refundStrategy) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Sales领域对象的addRefundStrategy方法 |
| SalesController.adjustRefundStrategy | 语法 | public ResultMessage adjustRefundStrategy(RefundStrategy refundStrategy) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规范 |
|  | 后置条件 | 调用Sales领域对象的adjustRefundStrategy方法 |
| SalesController.askRefund | 语法 | public ResultMessage askRefund(String reason) |
|  | 前置条件 | 已创建一个Sales领域对象，用户已完成购票支付，并且输入符合输入规范 |
|  | 后置条件 | 调用Sales领域对象的askRefund方法 |
| Sales.getRechargeLog(long userId) | 语法 | public ResultMessage getRechargeLog(long userId) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规范 |
|  | 后置条件 | 调用Sales领域对象的getRechargeLog方法 |
| Sales.getConsumeLog(long userId) | 语法 | public ResultMessage getConsumeLog(long userId) |
|  | 前置条件 | 已创建一个Sales领域对象，并且输入符合输入规范 |
|  | 后置条件 | 调用Sales领域对象的getConsumeLog方法 |
| SalesController.giveCoupon | 语法 | public ResultMessage giveCoupon(Coupon coupn) |
|  | 前置条件 | 已创建一个Sales领域对象，用户以管理员身份登录 |
|  | 后置条件 | 调用Sales领域对象的giveCoupon方法 |
| Sales.selectCoupon | 语法 | public ResultMessage selectCoupon() |
|  | 前置条件 | 已创建一个Sales领域对象，用户以管理员身份登录 |
|  | 后置条件 | 调用Sales领域对象的selectCoupon方法 |
| 需要的服务（需接口） |  |  |
| 服务名 |  | 服务 |
| Sales.buyTicket |  | 观众买票 |
| Sales..getPrice |  | 获取买票所需支付的金额 |
| Sales.pay |  | 结算支付 |
| Sales.endSales |  | 结束该销售回合 |
| Sales.getRefundPrice |  | 获取退票能得到的金额数量 |
| Sales.refund |  | 退款支付 |
| Sales.addSalesPreferentialStrategy |  | 添加一个销售优惠策略对象 |
| Sales.adjustSalesPreferentialStrategy |  | 修改已有销售优惠策略对象 |
| Sales.selectFilm |  | 选择具体的电影场次 |
| Sales.selectSeat |  | 选择具体的座位 |
| Sales.showOrderInfo |  | 获取订单详情信息 |
| Sales.confirmOrder |  | 确认订单信息无误 |
| Sales.payStrategy |  | 选择具体的支付方式 |
| Sales.cancelOrder |  | 取消订单 |
| Sales.addSalesLog |  | 添加销售记录 |
| Sales.payLater |  | 请求稍后支付 |
| Sales.lockSeat |  | 锁定座位 |
| Sales.unlockSeat |  | 解锁座位 |
| Sales.addRefundStrategy |  | 添加一个退款策略对象 |
| Sales.adjustRefundStrategy |  | 修改退款策略对象 |
| Sales.getRechargeLog |  | 获取充值历史记录 |
| Sales.getConsumeLog |  | 获取消费历史记录 |
| Sales.giveCoupon |  | 发放优惠券 |
| Sales.selectCoupon |  | 选择优惠券 |


**表6    salesbl 的接口规范**

| 提供的服务（供接口） |  |  |
| :---: | --- | --- |
| Sales.buyTicket | 语法 | public ResultMessage buyTicket(long userId, int filmId, Date date) |
|  | 前置条件 | 已添加用户信息，电影信息和购票日期 |
|  | 后置条件 | 返回买票的结果 |
| Sales.getPrice | 语法 | public ResultMessage getPrice() |
|  | 前置条件 | 已添加购票用户信息、购买的电影票信息和优惠策略 |
|  | 后置条件 | 返回此销售回合中需要支付的总额 |
| Sales.pay | 语法 | public ResultMessage pay(int price) |
|  | 前置条件 | 已添加此销售回合中需要支付的总额信息，并确认订单 |
|  | 后置条件 | 返回支付的结果 |
| Sales.endSales | 语法 | public void endSales() |
|  | 前置条件 | 已支付 |
|  | 后置条件 | 结束此销售回合，持久化更新涉及的领域对象的数据 |
| Sales.getRefundPrice | 语法 | public ResultMessage getRefundPrice(Order order) |
|  | 前置条件 | 已支付并创建支付订单 |
|  | 后置条件 | 返回应退还的金额 |
| Sales.refund | 语法 | public ResultMessage refund(int price) |
|  | 前置条件 | 已获取应退还的金额 |
|  | 后置条件 | 返回退款的结果 |
| Sales.addSalesPreferentialStrategy | 语法 | public ResultMessage addSalesPreferentialStrategy(SalesPreferentialStrategy salesPreferentialStrategy) |
|  | 前置条件 | salesStrategy不为空 |
|  | 后置条件 | 返回添加优惠策略的结果，持久化更新涉及的领域对象的数据 |
| Sales.adjustSalesPreferentialStrategy | 语法 | public ResultMessage adjustSalesPreferentialStrategy(SalesPreferentialStrategy salesPreferentialStrategy) |
|  | 前置条件 | salesStrategy不为空 |
|  | 后置条件 | 返回修改优惠策略的结果，持久化更新涉及的领域对象的数据 |
| Sales.selectFilm | 语法 | public Film selectFilm(Film film) |
|  | 前置条件 | film不为空 |
|  | 后置条件 | 返回该电影场次的信息，包括起止时间、电影名、影厅名 |
| Sales.selectSeat | 语法 | public ResultMessage selectSeat(String seatLoc) |
|  | 前置条件 | seatLoc符合输入规范 |
|  | 后置条件 | 返回座位选择的结果 |
| Sales.showOrderInfo | 语法 | public void showOrderInfo() |
|  | 前置条件 | 场次和座位选择完毕 |
|  | 后置条件 | 显示此销售回合的订单详情，包括价格、座位信息、时间信息、影片信息 |
| Sales.confirmOrder | 语法 | public void confirmOrder(boolean checked) |
|  | 前置条件 | 用户确认订单无误 |
|  | 后置条件 | 准备进行支付 |
| Sales.payStrategy | 语法 | public ResultMessage payStrategy(PayStrategy payStrategy) |
|  | 前置条件 | payStrategy符合输入规范 |
|  | 后置条件 | 结束支付方式选择，进入到具体的支付任务 |
| Sales.cancelOrder | 语法 | public ResultMessage cancelOrder() |
|  | 前置条件 | 已经确认订单 |
|  | 后置条件 | 解除座位占用状态，返回到正常流程中的选座阶段 |
| Sales.addSalesLog | 语法 | public ResultMessage addSalesLog(long userId, int filmId, Date date, int price, SalesType salesType) |
|  | 前置条件 | 支付任务完成，或者退票任务完成 |
|  | 后置条件 | 结束销售任务，持久化更新涉及的领域对象的数据 |
| Sales.payLater | 语法 | public ResultMessage payLater() |
|  | 前置条件 | 用户选择稍后支付或者支付时异常退出 |
|  | 后置条件 | 订单保持正在支付状态15分钟，超时未支付则自动取消订单 |
| Sales.lockSeat | 语法 | public ResultMessage lockSeat() |
|  | 前置条件 | 完成确认订单任务 |
|  | 后置条件 | 保持座位被占用状态，直到取消订单，返回被占用的座位号 |
| Sales.unlockSeat | 语法 | public ResultMessage unlockSeat() |
|  | 前置条件 | 完成取消订单任务 |
|  | 后置条件 | 解除座位被占用状态，返回解除占用的座位号 |
| Sales.addRefundStrategy | 语法 | public ResultMessage addRefundStrategy(RefundStrategy refundStrategy) |
|  | 前置条件 | refundStrategy符合输入规范 |
|  | 后置条件 | 结束添加退票策略任务，返回添加退款策略结果 |
| Sales.adjustRefundStrategy | 语法 | public ResultMessage adjustRefundStrategy(RefundStrategy refundStrategy) |
|  | 前置条件 | refundStrategy存在并符合输入规范 |
|  | 后置条件 | 结束修改退票策略任务，返回修改退款策略结果 |
| Sales.askRefund | 语法 | public ResultMessage askRefund(Order order) |
|  | 前置条件 | 已支付并创建支付订单 |
|  | 后置条件 | 返回退款的结果 |
| Sales.getRechargeLog | 语法 | public ResultMessage getRechargeLog(long userId) |
|  | 前置条件 | userId不为空，且对应观众存在 |
|  | 后置条件 | 返回观众充值的历史纪录 |
| Sales.getConsumeLog | 语法 | public ResultMessage getConsumeLog(long userId) |
|  | 前置条件 | userId不为空，且对应观众存在 |
|  | 后置条件 | 返回观众消费的历史纪录 |
| Sales.giveCoupon | 语法 | public ResultMessage giveCoupon(Coupon coupn, long userId) |
|  | 前置条件 | 以管理员身份登录 |
|  | 后置条件 | 增加涉及领域的持久化对象的数据，返回增加结果 |
| Sales.selectCoupon | 语法 | public ResultMessage selectCoupon() |
|  | 前置条件 | 以管理员身份登录，并准备赠送优惠券 |
|  | 后置条件 | 返回准备赠送的优惠券 |
| 需要的服务（需接口） |  |  |
| 服务名 |  | 服务 |
| DatabaseFacory.getSalesDatabase |  | 得到Sales数据库的服务的引用 |
| SalesDataService.insert(SalesPO po) |  | 在数据库中插入单一持久化对象 |
| SalesDataService.delete(SalesPO po) |  | 在数据库中删除单一持久化对象 |
| SalesDataService.update(SalesPO po) |  | 在数据库中更新单一持久化对象 |
| SalesDataService.find(int id) |  | 根据ID在数据库中查找单一持久化对象 |
| SalesDataService.finds(String field, int value) |  | 根据字段名和值进行查找多个持久化对象 |
| Arrangment.getArrangementList(Date date) |  | 根据日期在Arrangement数据库查找多个持久化对象 |
| User.getUser(int id) |  | 根据ID在User数据库查找单一持久化对象 |
| User.finds(String field, int value) |  | 根据字段名和值进行查找多个持久化对象 |
| Vip.getVip(int id) |  | 根据ID在Vip数据库查找单一持久化对象 |
| Movie.getMovie(int id) |  | 根据ID在Movie数据库查找单一持久化对象 |

   (4) 业务逻辑层的动态模型<br />![买票退票赠送优惠券.jpg](https://cdn.nlark.com/yuque/0/2019/jpeg/292738/1556973637302-23e1483b-e178-4e81-abc7-9cd3f7a81356.jpeg#align=left&display=inline&height=3397&name=%E4%B9%B0%E7%A5%A8%E9%80%80%E7%A5%A8%E8%B5%A0%E9%80%81%E4%BC%98%E6%83%A0%E5%88%B8.jpg&originHeight=3397&originWidth=2164&size=189535&status=done&width=2164)<br />![新增、修改退票策略重构.jpg](https://cdn.nlark.com/yuque/0/2019/jpeg/292738/1556938602253-764277cf-4f3f-493e-be9f-124fd104fad5.jpeg#align=left&display=inline&height=1556&name=%E6%96%B0%E5%A2%9E%E3%80%81%E4%BF%AE%E6%94%B9%E9%80%80%E7%A5%A8%E7%AD%96%E7%95%A5%E9%87%8D%E6%9E%84.jpg&originHeight=1556&originWidth=3171&size=215366&status=done&width=3171)<br />     **                                                      图10    salesbl 的顺序图**<br />![Sales对象状态图.jpg](https://cdn.nlark.com/yuque/0/2019/jpeg/292738/1556900574047-0d07d179-9067-4736-a35e-7454acfb0992.jpeg#align=left&display=inline&height=933&name=Sales%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81%E5%9B%BE.jpg&originHeight=933&originWidth=1915&size=54139&status=done&width=1915)<br />     **                                                      图11    salesbl 对象状态图**<br />         （5）业务逻辑层的设计原理<br />          利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制委托器委托给不同的领域对象。
<a name="0Hf20"></a>
####         4.1.3 moviebl 模块
   （1）模块概述<br />           moviebl 模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br />           Moviebl 模块的职责及接口参见软件体系结构描述文档表21.<br />         （2）整体结构<br />           根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加businesslogicservice.movieblservice.MovieBLService接口。业务逻辑层和数据层之间添加dataservice.moviedataservice.MovieDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了Controller，这样在处理电影的业务逻辑时，Controller会调用businesslogicservice.movieblservice.MovieBLService接口，委托给Movie对象。MoviePo是作为电影信息的持久化对象被添加到设计模型中去的。而MovieList和Film的添加作为容器类。Film电影的信息数据，标记电影的职责。而MovieList封装了关于Film的数据集的数据结构的秘密和及上架电影、统计电影的想看人数、查看电影列表、查看电影详情、搜索电影、下架电影、修改电影的职责。<br />           moviebl 模块的设计如图12所示。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556590863909-c5185fea-c3b8-4d5b-9cdc-00ad2cabafb6.png#align=left&display=inline&height=1196&originHeight=1196&originWidth=1390&status=done&width=1390)<br />                                                    **图12     moviebl 模块各个类的设计**<br />             moviebl 模块各个类的职责如表7所示。<br />                                                    **表7     moviebl 模块各个类的职责**

| 模块 | 职责 |  |
| --- | --- | --- |
| MovieController | 负责实现业务逻辑处理的委托 |  |
| Movie | 电影的领域模型对象，拥有电影列表，可以帮助完成电影界面所需要的服务 |  |
| User | 系统用户的领域模型对象，拥有用户的信息，可以提供用户的id |  |

   （3）模块内部类的接口规范<br />           MovieController和Movie的接口规范如表8和表9所示<br />   
   **表8     MovieController 的接口规范**


|  |  |  |
| :---: | --- | --- |
| 提供的服务（供接口） |  |  |
| MovieController.addMovie | 语法 | publicResultMessage addMovie(String info) |
|  | 前置条件 | 已创建Movie对象，info不为空 |
|  | 后置条件 | 调用Movie领域对象的addMovie方法 |
| MovieController.deleteMovie | 语法 | public ResultMessage deleteMovie(Film film) |
|  | 前置条件 | 已创建Movie对象，film不为空 |
|  | 后置条件 | 调用Movie领域对象的deleteMovie方法 |
| MovieController.adjustMovie | 语法 | public ResultMessage adjustMovie(Film film,String adjustment) |
|  | 前置条件 | 已创建Movie对象，film,adjustment不为空 |
|  | 后置条件 | 调用Movie领域对象的adjustMovie方法 |
| MovieController.getWantToSeeNumber | 语法 | public Chart getWantToSeeNumber(Film film,Date,start,Date end) |
|  | 前置条件 | 已创建Movie对象，film,start,end不为空 |
|  | 后置条件 | 调用Movie领域对象的getWantToSeeNumber方法 |
| MovieController.getMovieList  | 语法 | public movieList getMovieList() |
|  | 前置条件 | 已创建Movie对象，选择查看已上架电影列表 |
|  | 后置条件 | 调用Movie领域对象的getMovieList 方法 |
| MovieController.getMovieDetail | 语法 | public ArrayList getMovieDetail(Film film)  |
|  | 前置条件 | 已创建Movie对象，film不为空 |
|  | 后置条件 | 调用Movie领域对象的getMovieDetail方法 |
| MovieController.markMovie | 语法 | public ResultMessage markMovie(User user,Film film) |
|  | 前置条件 | 已创建Movie对象，user,film不为空 |
|  | 后置条件 | 调用Movie领域对象的markMovie方法 |
| MovieController.searchMovie | 语法 | public movieList searchMovie(String key) |
|  | 前置条件 | 已创建Movie对象，key不为空 |
|  | 后置条件 | 调用Movie领域对象的searchMovie方法 |
| 需要的接口（需接口） |  |  |
| 服务名 |  | 服务 |
| Movie.addMovie(String info) |  | 上架电影 |
| Movie.deleteMovie(Film film) |  | 下架电影 |
| Movie. adjustMovie(Film film,String adjustment) |  | 修改电影 |
| Movie.getWantToSeeNumber(Film film,Date,start,Date end) |  | 获取想看人数 |
| Movie.getMovieList() |  | 获取电影列表 |
| Movie.getMovieDetail(Film film)  |  | 获取电影详情 |
| Movie.markMovie(User user,Film film) |  | 标记电影 |
| Movie.searchMovie(String key) |  | 搜索电影 |

   **表9     Movie 的接口规范**

|  |  |  |
| :---: | --- | --- |
| 提供的服务（供接口） |  |  |
| Movie.addMovie | 语法 | public ResultMessage addMovie(String info) |
|  | 前置条件 | info不为空 |
|  | 后置条件 | 根据输入的info信息，增加涉及领域的持久化对象的数据，并返回上架结果 |
| Movie.deleteMovie | 语法 | public ResultMessage deleteMovie(Film film) |
|  | 前置条件 | film不为空 |
|  | 后置条件 | 根据输入的film信息，删除涉及领域的持久化对象的数据，并返回下架结果 |
| Movie.adjustMovie | 语法 | public ResultMessage adjustMovie(Film film,String adjustment) |
|  | 前置条件 | film,adjustment不为空 |
|  | 后置条件 | 根据输入的film,adjustment信息，修改涉及领域的持久化对象的数据，并返回修改结果 |
| Movie.getWantToSeeNumber | 语法 | public Chart getWantToSeeNumber(Film film,Date,start,Date end) |
|  | 前置条件 | film,start,end不为空 |
|  | 后置条件 | 根据film,start和end返回指定电影在指定时间段内想看人数统计图表 |
| Movie.getMovieList  | 语法 | public movieList getMovieList() |
|  | 前置条件 | 选择查看已上架电影列表 |
|  | 后置条件 | 显示电影列表 |
| Movie.getMovieDetail | 语法 | public ArrayList getMovieDetail(Film film)  |
|  | 前置条件 | film不为空 |
|  | 后置条件 | 根据film返回指定电影的详细信息（包括名称、电影宣传海报、导演、编剧、主演、类型、制片国家/地区、语言、上映日期、片长，想看人数） |
| Movie.markMovie | 语法 | public ResultMessage markMovie(User user,Film film) |
|  | 前置条件 | user,film不为空 |
|  | 后置条件 | 修改涉及领域的持久化对象的数据，并根据user,film返回标记结果 |
| Movie.searchMovie | 语法 | public movieList searchMovie(String key) |
|  | 前置条件 | key不为空 |
|  | 后置条件 | 根据keyword查找所有名称、主演和介绍中含有指定关键词的电影，并返回相应电影列表 |
| 需要的接口（需接口） |  |  |
| 服务名 |  | 服务 |
| DatabaseFacory.getMovieDataBase |  | 得到Movie数据库的服务的引用 |
| MovieDataService.insert(MoviePO po) |  | 在数据库中插入单一持久化对象 |
| MovieDataService.update(MoviePO po) |  | 在数据库中更新单一持久化对象 |
| MovieDataService.find(int id) |  | 在数据库中查找单一持久化变量 |
| User.getUser(int id) |  | 根据id在User数据库中获得持久化变量 |

   （4）业务逻辑层的动态模型<br />           图13表明了影院管理系统中，当员工上架电影时，电影业务逻辑处理的相关对象之间的协作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556507514455-51ca0b39-812c-4299-949a-53bc2d435a2a.png#align=left&display=inline&height=610&originHeight=610&originWidth=1181&size=0&status=done&width=1181)<br />                                                            **图13    上架电影的顺序图**<br />           图14表明了影院管理系统中，当员工下架电影时，电影业务逻辑处理的相关对象之间的协作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556507570403-4d0df397-3aee-4f97-82ce-aa11b1cbf787.png#align=left&display=inline&height=610&originHeight=610&originWidth=1181&size=0&status=done&width=1181)<br />                                                           ** 图14    下架电影的顺序图**<br />           图15表明了影院管理系统中，当员工修改电影时，电影业务逻辑处理的相关对象之间的协作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556508091275-b9e885c1-de91-4712-a01e-d466eb25c0aa.png#align=left&display=inline&height=610&originHeight=610&originWidth=1181&size=0&status=done&width=1181)<br />                                                          **  图15    修改电影的顺序图**<br />           图16表明了影院管理系统中，当用户查看电影列表时，电影业务逻辑处理的相关对象之间的协作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556508172468-d1d9f4fe-153e-49b6-865e-2704d346a05b.png#align=left&display=inline&height=610&originHeight=610&originWidth=1181&size=0&status=done&width=1181)<br />                                                            **图16    查看电影列表的顺序图**<br />           图17表明了影院管理系统中，当用户查看电影详情时，电影业务逻辑处理的相关对象之间的协作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556508298894-3c17066e-78f9-4539-a948-c32f263a2aaf.png#align=left&display=inline&height=610&originHeight=610&originWidth=1181&size=0&status=done&width=1181)<br />                                                     **       图17    查看电影详情的顺序图**<br />           图18表明了影院管理系统中，当用户标记电影详情时，电影业务逻辑处理的相关对象之间的协作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556509360638-b7b771d4-0ca7-4d48-a91e-95c38013a29f.png#align=left&display=inline&height=610&originHeight=610&originWidth=1181&size=0&status=done&width=1181)<br />                                             **               图18    搜索电影详情的顺序图**<br />           图19表明了影院管理系统中，当管理员统计电影想看人数时，电影业务逻辑处理的相关对象之间的协作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556518230512-a2b514f9-5757-4959-a8a1-2905a6884938.png#align=left&display=inline&height=610&originHeight=610&originWidth=1181&size=0&status=done&width=1181)<br />                                          **                  图19    统计电影想看人数的顺序图**<br />           图20表明了影院管理系统中，当用户标记电影时，电影业务逻辑处理的相关对象之间的协作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556518701663-ddad6c64-9c60-4589-b357-53e103f6a9a7.png#align=left&display=inline&height=610&originHeight=610&originWidth=1181&size=0&status=done&width=1181)<br />                                                       **     图20   标记电影的顺序图**<br />           如图21所示的状态图描述了Movie对象的生存期间的状态序列、引起转移的事件，以及状态转移而伴随的动作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556522653404-35d16b69-d3a0-45a1-af83-3bce8558e589.png#align=left&display=inline&height=459&originHeight=459&originWidth=706&size=0&status=done&width=706)<br />                                                            **图21   Movie 对象状态图**<br />          （5）业务逻辑层的设计原理<br />           利用委托时控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同领域对象。
<a name="j1IUx"></a>
#### 
<a name="RrPgJ"></a>
####         4.1.4 arrangementbl模块
   （1）模块概述<br />           arrangementbl 模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br />           Arrangementbl 模块的职责及接口参见软件体系结构描述文档表24.<br />         （2）整体结构<br />           根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如展示层和业务逻辑层之间，我们添加businesslogicservice.arrangementblservice.ArrangementBLService接口。业务逻辑层和数据层之间添加dataservice.arrangementdataservice.ArrangementDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了Controller，这样在处理电影的业务逻辑时，Controller会调用businesslogicservice.arrangementblservice.ArrangementBLService接口，委托给Arrangment对象。ArrangementPo是作为电影信息的持久化对象被添加到设计模型中去的。而ArrangementList的添加作为容器类。ArrangementList封装了关于Arrangement的数据集的数据结构的秘密和添加排片信息、查看排片信息、删除排片信息、修改排片信息的职责。<br />           arrangementbl 模块的设计如图22所示。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556972919184-8e6c2c49-c4fb-45b6-a1f2-7f6771e9d378.png#align=left&display=inline&height=1268&originHeight=1268&originWidth=1884&size=0&status=done&width=1884)<br />                                               **             图22   moviebl 模块各个类的设计**<br />**             arrangementbl 模块各个类的职责如表10所示。<br />**                                                    表10      Arrangementbl 模块各个类的职责**

|  |  |  |
| --- | --- | --- |
| 模块 | 职责 |  |
| ArrangementController | 负责实现业务逻辑处理的委托 |  |
| Arrangment | 排片的领域模型对象，可以帮助完成排片界面所需要的服务 |  |
| Movie | 电影的领域模型对象，拥有电影的信息，可以提供电影的想看人数 |  |
| Hall | 影厅的领域模型对象，拥有影厅的信息 |  |

   （3）模块内部类的接口规范<br />           ArrangementController和Arrangement的接口规范如表11和12所示。<br />                                             **     表11     ArrangementController 的接口规范**

|  |  |  |
| :---: | --- | --- |
| 提供的服务（供接口） |  |  |
| ArrangementController.add | 语法 | public ResultMessage addArrangement(Film film,Date date,Hall hall) |
|  | 前置条件 | 已创建一个Arrangement领域对象，movie和date符合输入规则 |
|  | 后置条件 | 调用Arrangement领域对象的add方法 |
| ArrangementController.check | 语法 | public Film checkArrangement(MovieHall Moviehall, String name,String view) |
|  | 前置条件 | 已创建一个Arrangement领域对象，hall、name、view不同时为空且符合输入规则 |
|  | 后置条件 | 调用Arrangement领域对象的check方法 |
| ArrangementController.delete | 语法 | public ResultMessage deleteArrangement(ArrangementList arrangementList, String deletement) |
|  | 前置条件 | 已创建一个Arrangement领域对象，arrangementList符合输入规则 |
|  | 后置条件 | 调用Arrangement领域对象的delete方法 |
| ArrangementController.adjust | 语法 | public ResultMessage adjustArrangement(ArrangementList arrangementList, String adjustment) |
|  | 前置条件 | 已创建一个Arrangement领域对象，arrangementList和adjustment符合输入规则 |
|  | 后置条件 | 调用Arrangement领域对象的adjust方法 |
| ArrangementController.setTime | 语法 | public ResultMessage setTime(ArrangementList arrangementList, String time) |
|  | 前置条件 | 已创建一个Arrangement领域对象，arrangementList和time符合输入规则 |
|  | 后置条件 | 调用Arrangement领域对象的setTime方法 |
| ArrangementController.adjustTime | 语法 | public ResultMessage adjustTime(ArrangementList arrangementList, String time) |
|  | 前置条件 | 已创建一个Arrangement领域对象，arrangementList和time符合输入规则 |
|  | 后置条件 | 调用Arrangement领域对象的adjustTime方法 |
| 需要的服务（需接口） |  |  |
| 服务名 |  | 服务 |
| Arrangment.addArrangement(Film film,Date date,Hall hall) |  | 添加排片 |
| Arrangment.checkArrangement(MovieHall Moviehall, String name,String view) |  | 查看排片 |
| Arrangment.deleteArrangement(ArrangementList arrangementList, String deletement) |  | 删除排片 |
| Arrangment.adjustArrangement(ArrangementList arrangementList, String adjustment) |  | 修改排片 |
| Arrangment.setTime(ArrangementList arrangementList, String time) |  | 设置可见时间 |
| Arrangment. adjustTime(ArrangementList arrangementList, String time) |  | 修改可见时间 |

**                                                  表12     Arrangement 的接口规范**

|  |  |  |
| :---: | --- | --- |
| 提供的服务（供接口） |  |  |
| Arrangement.add | 语法 | public ResultMessage addArrangement(Film film,Date date,Hall hall) |
|  | 前置条件 | movie和date符合输入规则 |
|  | 后置条件 | 增加涉及领域的持久化对象的数据，返回创建结果 |
| Arrangement.check | 语法 | public Film checkArrangement(MovieHall Moviehall, String name,String view) |
|  | 前置条件 | hall、name、view不同时为空且符合输入规则 |
|  | 后置条件 | 返回查看的结果 |
| Arrangement.delete | 语法 | public ResultMessage deleteArrangement(ArrangementList arrangementList, String deletement) |
|  | 前置条件 | arrangementList符合输入规则 |
|  | 后置条件 | 删除涉及领域的持久化对象的数据，根据arrangement返回删除结果 |
| Arrangement.adjust | 语法 | public ResultMessage adjustArrangement(ArrangementList arrangementList, String adjustment) |
|  | 前置条件 | arrangementList和adjustment符合输入规则 |
|  | 后置条件 | 修改涉及领域的持久化对象的数据，根据arrangement返回修改结果 |
| Arrangement.setTime | 语法 | public ResultMessage setTime(ArrangementList arrangementList, String time) |
|  | 前置条件 | arrangementList和time符合输入规则 |
|  | 后置条件 | 增加涉及领域的持久化对象的数据，返回创建结果 |
| Arrangement.adjustTime | 语法 | public ResultMessage adjustTime(ArrangementList arrangementList, String time) |
|  | 前置条件 | arrangementList和time符合输入规则 |
|  | 后置条件 | 修改涉及领域的持久化对象的数据，根据arrangement返回修改结果 |
| 需要的服务（需接口） |  |  |
| 服务名 |  | 服务 |
| DatabaseFacory.getArrangementDatabase |  | 得到Arrangement数据库的服务的引用 |
| ArrangementDataService.insert(Arrangement po) |  | 在数据库中插入单一持久化对象 |
| ArrangementDataService.delete(Arrangement po) |  | 在数据库中删除单一持久化对象 |
| ArrangementDataService.update(Arrangement po)) |  | 在数据库中更新单一持久化对象 |
| ArrangementDataService.find(int id) |  | 在数据库中查找单一持久化对象 |
| Movie.getWantToSeeList() |  | 从Movie数据库获得单一持久化对象 |
| Hall.getMovieHall(int id) |  | 根据id从Hall数据库获得单一持久化对象 |

   （4）业务逻辑层的动态模型<br />           图23表明了影院管理系统中，当员工添加排片信息时，电影业务逻辑处理的相关对象之间的协作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556547854302-02802f93-d17e-4baf-8469-6e202fb770fe.png#align=left&display=inline&height=610&originHeight=610&originWidth=1181&size=0&status=done&width=1181)<br />       **                                                    图23    添加排片信息的顺序图**<br />           其他顺序图与此类似。<br />           如图24所示的状态图描述了Arrangement对象的生存期间的状态序列、引起转移的事件，以及状态转移而伴随的动作。<br />![](https://cdn.nlark.com/yuque/0/2019/png/293519/1556550977624-75b99560-cc7e-4c22-8594-4f76b8d192f4.png#align=left&display=inline&height=605&originHeight=605&originWidth=888&size=0&status=done&width=888)<br />                                               **             图24   Arrangement 对象状态图**<br />           （5）业务逻辑层的设计原理<br />             利用委托时控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同领域对象。
<a name="CivHE"></a>
#### 
<a name="HS6ML"></a>
####         4.1.5 userbl模块
   （1）模块概述<br />           userbl 模块承担的需求参见需求规格说明文档功能需求及相关非功能需求<br />           Userbl 模块的职责及接口参见软件体系结构描述文档<br />         （2） 整体结构<br />           userbl 模块的设计如图25所示<br />![userbl模块各个类的设计.jpg](https://cdn.nlark.com/yuque/0/2019/jpeg/292738/1556938693832-1dda59b5-cb89-4341-af41-a77bd44a58cc.jpeg#align=left&display=inline&height=1002&name=userbl%E6%A8%A1%E5%9D%97%E5%90%84%E4%B8%AA%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1.jpg&originHeight=1002&originWidth=1433&size=38525&status=done&width=1433)<br />                                                   **  图25    userbl 模块各个类的设计**<br />           userbl模块各个类的职责如表所示<br />                                                     **表13    userbl 模块各个类的职责**

|                   模块 |                                              职责 |
| --- | --- |
| UserController | 负责实现用户界面所需要的服务 |
| User | 系统用户的领域模型对象，拥有一个用户数据的姓名和密码，可以解决登陆问题 |
| UserRole | 系统用户职责的领域对象，用来表明正在使用系统的用户的职责，由此判定可执行的不同操作 |
| TicketList | 系统用户（观众）持有电影票列表的领域模型对象，用来存储用户所持有的电影票对象 |
| Ticket | 系统用户（观众）持有的电影票的领域模型对象，拥有对应电影的场次、影厅、座位等信息。 |


   (3) 模块内部类的接口规范<br />           UserController和User的接口规范如表14和表15所示<br />**                                                    表14    userController 的接口规范**

| 提供的服务（供接口） |  |  |
| :---: | --- | --- |
| UserController.login | 语法 | public ResultMessage login(long id, String password) |
|  | 前置条件 | 已创建一个User领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用user领域对象的login方法 |
| UserController.createNewAccount | 语法 | public ResultMessage createNewAccount(long id, String password, String passwordTwo) |
|  | 前置条件 | 已创建一个User领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用User领域的createNewAccount方法 |
| UserController.addMember | 语法 | public ResultMessage addMember(long id, String password, UserRole role) |
|  | 前置条件 | 已创建一个User领域对象，输入符合输入规则，且输入id对应的用户账号存在 |
|  | 后置条件 | 调用User领域对象的addMember方法 |
| UserController.deleteMember | 语法 | public ResultMessage deleteMember(long id, UserRole role) |
|  | 前置条件 | 已创建一个User领域对象，输入符合输入规则，且输入id对应的用户账号存在 |
|  | 后置条件 | 调用User领域对象的deleteMember方法 |
| UserController.searchMember | 语法 | public ResultMessage searchMember(long id, UserRole role) |
|  | 前置条件 | 已创建一个User领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用User领域对象的searchMember方法 |
| UserController.adjustMember | 语法 | public ResultMessage adjustMember(int mode, Type details) |
|  | 前置条件 | 已创建一个User领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用User领域对象的adjustMember方法 |
| UserController.getTicket | 语法 | public Ticket getTicket(int id) |
|  | 前置条件 | 已创建一个User领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用User领域对象的getTicket方法 |
| User.getTicketList | 语法 | public Ticket getTcketList() |
|  | 前置条件 | 已创建一个User领域对象 |
|  | 后置条件 | 调用User领域对象的getTicketList方法 |
| 需要的服务（需接口） |  |  |
| 服务名 |  | 服务 |
| User.login |  | 用户登录 |
| User.createNewAccount |  | 加入一个用户账户对象 |
| User.addMember |  | 加入一个用户成员对象 |
| User.deleteMember |  | 删除一个用户成员对象 |
| User.searchMember |  | 查找一个用户成员对象 |
| User.adjustMember |  | 修改一个用户成员对象信息 |
| User.getTicket |  | 获取一个用户持有的电影票对象 |
| User.getTicketList |  | 获取一个用户持有的电影票列表对象 |

**                                                              表15    userbl 的接口规范**

| 提供的服务（供接口） |  |  |
| :---: | --- | --- |
| User.login | 语法 | public ResultMessage login(long id, String password) |
|  | 前置条件 | id，password均不为空 |
|  | 后置条件 | 查找是否存在相应的User, 根据输入的password返回登录验证的结果 |
| User.createNewAccount | 语法 | public ResultMessage createNewAccount(long id, String password, String passwordTwo) |
|  | 前置条件 | id, password, passwordTwo均不为空；password和passwordTwo相同 |
|  | 后置条件 | 根据输入的id和password，增加涉及领域的持久化对象的数据，返回注册结果 |
| User.addMember | 语法 | public ResultMessage addMember(long id, String password, UserRole role) |
|  | 前置条件 | id，password均不为空，role符合输入规则 |
|  | 后置条件 | 增加涉及领域的持久化对象的数据，返回创建结果 |
| User.deleteMember | 语法 | public ResultMessage deleteMember(long id, UserRole role) |
|  | 前置条件 | id不为空，role符合输入规则 |
|  | 后置条件 | 删除涉及领域的持久化对象的数据，根据id和role返回删除结果 |
| User.searchMember | 语法 | public ResultMessage searchMember(long id, UserRole role) |
|  | 前置条件 | id不为空，role符合输入规则 |
|  | 后置条件 | 查找是否存在对应的User,根据id和role返回搜索结果 |
| User.adjustMember | 语法 | public ResultMessage adjustMember(int mode, Type details) |
|  | 前置条件 | mode符合输入要求 |
|  | 后置条件 | 根据mode确定修改的内容，根据details持久化更新涉及领域对象的数据，返回更新结果 |
| User.getTicket | 语法 | public Ticket getTicket(int id) |
|  | 前置条件 | id符合输入要求 |
|  | 后置条件 | 根据id返回相关的电影票信息 |
| User.getTicketList | 语法 | public Ticket getTicketList() |
|  | 前置条件 | 用户的ticketList存在 |
|  | 后置条件 | 返回用户持有的所有电影票 |
| 需要的服务（需接口） |  |  |
| 服务名 |  | 服务 |
| DatabaseFacory.getUserDatabase |  | 得到User数据库的服务的引用 |
| UserDataService.insert(UserPO po) |  | 在数据库中插入单一持久化对象 |
| UserDataService.delete(UserPO po) |  | 在数据库中删除单一持久化对象 |
| UserDataService.update(UserPO po) |  | 在数据库中更新单一持久化对象 |
| UserDataService.find(int id) |  | 在数据库中查找单一持久化对象 |

   （4）业务逻辑层的动态模型<br />![User顺序图重构.jpg](https://cdn.nlark.com/yuque/0/2019/jpeg/292738/1556885262635-2cb6852e-85bf-477b-be7c-8675f89222fa.jpeg#align=left&display=inline&height=1357&name=User%E9%A1%BA%E5%BA%8F%E5%9B%BE%E9%87%8D%E6%9E%84.jpg&originHeight=1357&originWidth=2077&size=111966&status=done&width=2077)<br />**                                                           图26    userbl 的顺序图**<br />![未命名文件 (1).jpg](https://cdn.nlark.com/yuque/0/2019/jpeg/292738/1556887240700-6ff0b3e1-1ee5-4250-83e9-993d04aeff34.jpeg#align=left&display=inline&height=512&name=%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%281%29.jpg&originHeight=512&originWidth=893&size=26117&status=done&width=893)<br />**                                                            图27    User 对象状态图**<br />           （5）业务逻辑层的设计原理<br />             利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制委托器委托给不同的领域对象。

<a name="UN8Eu"></a>
####         4.1.6 statisticsbl模块
  （1）模块概述<br />             statisticsbl 模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br />             Statisticsbl 模块的职责及接口参见软件体系结构描述文档表23<br />           （2）整体结构<br />             根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如在展示层和业务逻辑层之间，我们添加businesslogicservice.statisticsblservice.StatisticsBLService接口。业务逻辑层和数据层之间添加dataservice.statisticsdataservice.StatisticsDataService接口。为了隔离业务逻辑层职责和逻辑控制职责，我们增加了StatisticsController，这样StatisticsController将会对业务的销售逻辑处理委托给Statistics对象。StatisticsPO是作为统计记录的持久化对象被添加到设计模型中去的。而DailyCount的添加是为了分离每日更新统计量的职责。Salesinfo, Movieinfo和Arrangementinfo都是根据依赖倒置原则，为了消除循环依赖而产生的接口。<br />             statisticsbl 模块的设计如图28所示。<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/293518/1556549422342-573aaa43-37b7-40d2-97fd-8cb94f6b2daa.png#align=left&display=inline&height=634&name=image.png&originHeight=1267&originWidth=1996&size=174283&status=done&width=998)<br />**                                                          图28    statisticsbl 模块各个类的设计**<br />   <br />             statisticsbl模块个各类的职责如表16所示

**                                                    表16      statisticsbl 模块各个类的职责**

|  |  |  |
| --- | --- | --- |
| 模块 | 职责 |  |
| StatisticsController | 负责统计界面的实现 |  |
| Statistics | 统计的领域模型对象，拥有一次统计所持有的开始日期、结束日期、统计类型等信息，帮助完成统计界面所需要的服务 |  |
| DailyCount | 负责对每日统计结果的计算 |  |

   （3）模块内部类的接口规范<br />             StatisticsController和Statistics的接口规范如表17和表18所示<br />**                                                    表17    StatisticsController 的接口规范**

| 提供的服务（供接口） |  |  |
| :---: | --- | --- |
| StatisticsController.getTopRatedMovie | 语法 | public String getTopRatedMovie(Date start, Date end) |
|  | 前置条件 | 已创建一个Statistics领域对象，且start和end不为空，而且end晚于start |
|  | 后置条件 | 调用Statistics领域对象的getTopRatedMovie方法 |
| StatisticsController.getAttendanceRate | 语法 | public Hashmap getAttendanceRate(Date date, Date end) |
|  | 前置条件 | 已创建一个Statistics领域对象，且start和end不为空，而且end晚于start |
|  | 后置条件 | 调用Statistics领域对象的getAttendanceRate方法 |
| StatisticsController.getAverageTicketPrice | 语法 | public double getAverageTicketPrice(Date start, Date end) |
|  | 前置条件 | 已创建一个Statistics领域对象，且start和end不为空，而且end晚于start |
|  | 后置条件 | 调用Statistics领域对象的getAverageTicketPrice方法 |
| StatisticsController.getBoxOffice | 语法 | public Hashmap getBoxOffice(Date start, Date end) |
|  | 前置条件 | 已创建一个Statistics领域对象，且start和end不为空，而且end晚于start |
|  | 后置条件 | 调用Statistics领域对象的getBoxOffice方法 |
| StatisticsController.getMovieArrangingRate | 语法 | public Hashmap getMovieArrangingRate(Date start, Date end) |
|  | 前置条件 | 已创建一个Statistics领域对象，且start和end不为空，而且end晚于start |
|  | 后置条件 | 调用Statistics领域对象的getMovieArrangingRate方法 |
| StatisticsController.countDaily | 语法 | public ResultMessage countDaily(String salesLog, ArrangementList arrangementList, WantToSeeList wantToSeeList) |
|  | 前置条件 | 已创建一个Statistics领域对象，且salesLog,arrangementList和wantToSeeList已生成 |
|  | 后置条件 | 调用Statistics领域对象的countDaily方法 |
| 需要的服务（需接口） |  |  |
| 服务名 |  | 服务 |
| Statistics.getTopRatedMovie(Date start, Date end) |  | 获取指定时间区间内的最受欢迎电影 |
| Statistics.getAttendanceRate(Date date, Date end) |  | 获取指定时间区间内的上座率 |
| Statistics.getAverageTicketPrice(Date start, Date end) |  | 获取指定时间区间内的客单价 |
| Statistics.getBoxOffice(Date start, Date end) |  | 获取指定时间区间内的票房 |
| Statistics.getMovieArrangingRate(Date start, Date end) |  | 获取指定时间区间内排片率 |
| Statistics.countDaily(String salesLog, ArrangementList arrangementList, WantToSeeList wantToSeeList) |  | 更新每日的统计数据 |

**                                                    表18    Statistics 的接口规范**

| 提供的服务（供接口） |  |  |
| :---: | --- | --- |
| Statistics.getTopRatedMovie | 语法 | public String getTopRatedMovie(Date start, Date end) |
|  | 前置条件 | start和end不为空，而且end晚于start |
|  | 后置条件 | 根据start和end返回指定时间段内最受欢迎电影的统计结果 |
| Statistics.getAttendanceRate | 语法 | public Hashmap getAttendanceRate(Date date, Date end) |
|  | 前置条件 | start和end不为空，而且end晚于start |
|  | 后置条件 | 根据start和end返回指定时间段内各电影上座率的统计结果 |
| Statistics.getAverageTicketPrice | 语法 | public double getAverageTicketPrice(Date start, Date end) |
|  | 前置条件 | start和end不为空，而且end晚于start |
|  | 后置条件 | 根据start和end返回指定时间段内客单价统计结果 |
| Statistics.getBoxOffice | 语法 | public Hashmap getBoxOffice(Date start, Date end) |
|  | 前置条件 | start和end不为空，而且end晚于start |
|  | 后置条件 | 根据start和end返回指定时间段内各电影票房统计结果 |
| Statistics.getMovieArrangingRate | 语法 | public Hashmap getMovieArrangingRate(Date start, Date end) |
|  | 前置条件 | start和end不为空，而且end晚于start |
|  | 后置条件 | 根据start和end返回指定时间段内各电影的排片率统计结果 |
| Statistics.countDaily | 语法 | public ResultMessage countDaily(String salesLog, ArrangementList arrangementList, WantToSeeList wantToSeeList) |
|  | 前置条件 | salesLog,arrangementList和wantToSeeList已生成 |
|  | 后置条件 | 根据salesLog,arrangementList和wantToSeeList统计当日数据，修改涉及领域的持久化对象的数据 |
| 需要的服务（需接口） |  |  |
| 服务名 |  | 服务 |
| DatabaseFacory.getStatisticsDatabase |  | 得到Statistics数据库的服务的引用 |
| StatisticsDataService.find(Date date) |  | 根据指定日期查找单一持久化对象 |
| StatisticsDataService.finds(Date start, Date end) |  | 根据开始日期和结束日期查找多个持久化对象 |
| Salses.getSalesLog(Date date) |  | 根据指定日期在Sales数据库获得单一持久化对象 |
| Arrangement.getArrangementList(Date date) |  | 根据指定日期在Arrangement数据库获得单一持久化对象 |
| Movie.getWantToSeeList() |  | 在Movie数据库获得单一持久化对象 |



   （4）业务逻辑层的动态模型<br />             图29表明了当影院员工在统计界面选择统计近期最受欢迎电影并输入时间区间以后，统计业务逻辑处理的相关对象之间的合作。对于电影想看人数、上座率、客单价、票房、排片率的统计与此类似。<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/293518/1556549083683-ffa99f9e-1c70-4a9f-b525-f82ee80d0b37.png#align=left&display=inline&height=479&name=image.png&originHeight=957&originWidth=1824&size=99307&status=done&width=912)<br />**                                                          图29   统计最受欢迎电影的顺序图**<br /> <br />             图30为Statistics领域对象想要进行每日统计量更新时的顺序图。<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/293518/1556549171349-1653dd24-eb57-487c-afd7-9342b6532637.png#align=left&display=inline&height=620&name=image.png&originHeight=1239&originWidth=1903&size=153308&status=done&width=951.5)<br />**                                                          图30   获得每日统计量的顺序图**<br />   <br />             如图31所示的状态图描述了Statistics对象的生存周期的状态序列、引起转移的事件，以及因状态转移而伴随的动作。<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/293518/1556549304461-a44d5df5-016e-4752-9c38-8b349604327d.png#align=left&display=inline&height=437&name=image.png&originHeight=873&originWidth=1564&size=121044&status=done&width=782)<br />**                                                          图31   Statistics 对象状态图**

   （5）业务逻辑层的设计原理<br />           利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同的领域对象。
<a name="6GlLI"></a>
####         4.1.7 hallbl模块
   （1）模块概述<br />           hallbl 模块承担的需求参见需求规格说明文档功能需求及相关非功能需求。<br />           Hallbl 模块的职责及接口参见软件系统结构描述文档表。<br />         （2）整体结构<br />           根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性，我们会添加接口。比如在展示层和业务逻辑层之间，我们添加businesslogicservice.hallblservice.HallBLService接口。业务逻辑层和数据层之间添加dataservice.halldataservice.HallDataService接口。为了隔离业务逻辑层职责和逻辑控制职责，我们增加了HallController，这样HallController将会对业务的销售逻辑处理委托给Hall对象。HallPO是作为会员卡的持久化对象被添加到设计模型中去的。HallList和MovieHall的添加是容器类。HallList类里封装了所有已添加的影厅信息，MovieHall类里保有影厅的id、名称、大小、座位类型信息。<br />           hallbl 模块的设计图如图32所示：<br />![hall模块各个类的设计.png](https://cdn.nlark.com/yuque/0/2019/png/293520/1556896200251-dfab412d-5baa-4b81-b6fa-b0c8784ae8ff.png#align=left&display=inline&height=1092&name=hall%E6%A8%A1%E5%9D%97%E5%90%84%E4%B8%AA%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1.png&originHeight=1092&originWidth=1239&size=38073&status=done&width=1239)

**                                                       图32    hallbl 模块各个类的设计**

           hallbl模块各个类的职责如表19所示：

**                                                     表19    hallbl 模块各个类的职责**

| HallController | 负责实现影厅界面所需要的服务 |  |
| :---: | --- | --- |
| Hall | 影厅的领域模型对象，拥有影厅列表、影厅所持有的id、名称、大小、座位类型，可以帮助完成影厅相关界面所需要的服务 |  |
| HallList | 影厅持有的影厅列表的领域模型对象，拥有所有已添加的影厅信息 |  |
| MovieHall | 会员卡持有的单个影厅的领域模型对象，拥有单个影厅的id、名称、大小、座位类型 |  |

   （3）模块内部类的接口规范<br />           HallController和Hall的接口规范如表20和表21所示<br />**                                                     表20    HallController 的接口规范**

| 提供的服务（供接口） |  |  |
| :---: | --- | --- |
| HallController.addHall | 语法 | public void addHall(movieHall hall) |
|  | 前置条件 | 已创建一个Hall领域对象，并且输入符合输入规则 |
|  | 后置条件 | 调用Hall领域对象的addHall方法 |
| HallController.getMovieHall | 语法 | public ResultMessage getMovieHall(int id) |
|  | 前置条件 | 已创建一个Hall领域对象，输入符合输入规则，且该影厅已存在 |
|  | 后置条件 | 调用Hall领域对象的getMovieHall方法 |
| HallController.adjustHall | 语法 | public void adjustHall(movieHall newHall, int id) |
|  | 前置条件 | 已创建一个Hall领域对象，输入符合输入规则，且该影厅已存在 |
|  | 后置条件 | 调用Hall领域对象的adjustHall方法 |
| HallController.deleteHall | 语法 | public  deleteHall( int id) |
|  | 前置条件 | 已创建一个Hall领域对象，输入符合输入规则，且该影厅已存在 |
|  | 后置条件 | 调用Hall领域对象的deleteHall方法 |
| HallController.endAdd | 语法 | public ResultMessage endAdd() |
|  | 前置条件 | 已创建一个Hall领域对象 |
|  | 后置条件 | 调用Hall领域对象的endAdd方法 |
| HallController.endAdjust | 语法 | public ResultMessage endAdjust() |
|  | 前置条件 | 已创建一个Hall领域对象 |
|  | 后置条件 | 调用Hall领域对象的endAdjust方法 |
| 需要的服务（需接口） |  |  |
| Hall.addHall(movieHall hall) |  | 录入一个影厅对象 |
| Hall.getMovieHall(int id) |  | 查找影厅信息 |
| Hall.adjustHall(movieHall newHall, int id) |  | 修改影厅信息 |
| Hall.deleteHall( int id) |  | 删除一个影厅对象 |
| Hall.endAdd() |  | 结束影厅录入 |
| Hall.endAdjust() |  | 结束影厅信息修改 |

   Hall的接口规范：<br />**                                                     表21    Hall 的接口规范**

| 提供的服务（供接口） |  |  |
| :---: | --- | --- |
| Hall.addHall | 语法 | public void addHall(movieHall hall) |
|  | 前置条件 | hall不为null |
|  | 后置条件 | 创建新影厅并添加该影厅的信息 |
| Hall.getMovieHall | 语法 | public ResultMessage getMovieHall(int id) |
|  | 前置条件 | id符合输入规则，对应id影厅存在 |
|  | 后置条件 | 返回此影厅的信息，包括名称、座位状况、影厅大小、屏幕类型 |
| Hall.adjustHall | 语法 | public void adjustHall(movieHall newHall, int id) |
|  | 前置条件 | 已添加对应id影厅的信息，对应id影厅存在 |
|  | 后置条件 | 修改指定影厅的信息 |
| Hall.deleteHall | 语法 | public  deleteHall( int id) |
|  | 前置条件 | 对应id影厅存在 |
|  | 后置条件 | 删除此影厅的信息，返回删除结果 |
| Hall.endAdd | 语法 | public ResultMessage endAdd() |
|  | 前置条件 | 已成功添加影厅 |
|  | 后置条件 | 返回添加结果，持久化更新涉及的领域对象的数据 |
| Hall.endAdjust | 语法 | public ResultMessage endAdjust() |
|  | 前置条件 | 已成功修改影厅信息 |
|  | 后置条件 | 返回调整结果，持久化更新涉及的领域对象的数据 |
| 需要的服务（需接口） |  |  |
| 服务名 |  | 服务 |
| DatabaseFacory.getHallDatabase |  | 得到Hall数据库的服务的引用 |
| HallDataService.insert(HallPO po) |  | 在数据库中插入单一持久化对象 |
| HallDataService.delete(HallPO po) |  | 在数据库中删除单一持久化对象 |
| HallDataService.update(HallPO po) |  | 在数据库中更新单一持久化对象 |
| HallDataService.find(String name) |  | 根据name在数据库中查找单一持久化对象 |
| HallDataService.finds(String field, int value) |  | 根据字段名和值进行查找多个持久化对象 |

   （4）业务逻辑层的动态模型<br />           图33表明了影院管理系统中，当用户点击录入影厅，影厅业务逻辑处理的相关对象之间的协作

![](https://cdn.nlark.com/yuque/0/2019/png/293520/1556886885405-e7c77b4e-44b9-4949-9569-f32662e2c18d.png#align=left&display=inline&height=424&originHeight=652&originWidth=1148&status=done&width=746)<br />**                                                       图33   录入影厅的顺序图**<br />           图34为Hall领域对象想要查找影厅信息时候的顺序图

![](https://cdn.nlark.com/yuque/0/2019/png/293520/1556892586508-6605f4f8-6b1f-410f-8b2c-a122b5693d0b.png#align=left&display=inline&height=424&originHeight=652&originWidth=1147&status=done&width=746)<br />**                                                       图34   查找影厅的顺序图**<br />           Hall领域对象想要修改影厅信息、删除影厅时候的顺序图类比图3

   图35所示的状态图描述了Hall对象的生存期间的状态序列、引起转移的事件，以及因状态转移而伴随的动作。

![](https://cdn.nlark.com/yuque/0/2019/png/293520/1556894194827-1ccf4b90-9b55-408a-80b0-1e726994e284.png#align=left&display=inline&height=347&originHeight=423&originWidth=910&status=done&width=746)<br />**                                                       图35   Hall 对象状态图**<br />         （5）业务逻辑层的设计原理<br />           利用委托式控制风格，每个界面需要访问的业务逻辑由各自的控制委托器委托给不同的领域对象。
<a name="I78Ra"></a>
## 5. 依赖视角
  图36是系统各自的包的依赖关系。

![](http://assets.processon.com/chart_image/5cb00396e4b02a2858e8bfe0.png#align=left&display=inline&height=2400&originHeight=2400&originWidth=2364&status=uploading&width=2364)

**                                                       图33   系统包图**                                      图33   系统包图**